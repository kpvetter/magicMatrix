#!/bin/sh
# Restart with tcl: -*- mode: tcl; tab-width: 8; -*- \
exec tclsh $0 ${1+"$@"}

##+##########################################################################
#
# newBoard.tsh -- <description>
# by Keith Vetter 2025-08-27
#
# TODO: change how ::NewBoard::GetBoard data is returned
#

namespace eval NewBoard {
    variable newBoard
    variable selected {}
    variable seed
    variable XMODE False
}

proc ::NewBoard::Create {size seed withBlobs} {
    variable newBoard
    global createAttempts

    # bad: set size 9; set seed 3064843536 ; set withBlobs 0
    # StartGame 9 3064843536

    try {
        for {set createAttempts 0} {$createAttempts < 100} {incr createAttempts} {
            if {$createAttempts == 20} {
                .c itemconfig finished -text "thinking..."
                update
            }
            ::NewBoard::_Create $size $seed $withBlobs
            set isSolvable [::Solve::IsSolvable ::NewBoard::newBoard]

            if {$isSolvable} return
        }
    } finally {
        .c itemconfig finished -text ""
        update
    }
    tk_messageBox -icon warning -message "This puzzle may require guessing"
}
proc ::NewBoard::Info {} {
    variable newBoard
    variable seed
    global createAttempts
    global solvingPasses
    global blobPasses

    set result {}
    lappend result size $newBoard(size) seed $seed
    lappend result withBlobs $newBoard(hasBlobs)
    lappend result createAttempts $createAttempts solvingPasses [llength $solvingPasses]
    if {$newBoard(hasBlobs)} {
        lappend result blobPasses $blobPasses
    }
    set command "StartGame $newBoard(size)x$newBoard(size)"
    if {$newBoard(hasBlobs)} { append command "-3D" }
    append command " $seed"

    puts $result
    return $command
}
proc ::NewBoard::GetBoard {} {
    # Returns board created by ::NewBoard::Create as a list of list of ints
    variable newBoard

    set result {}
    set line {-}
    foreach col $newBoard(indices) {
        lappend line $newBoard(col,$col)
    }
    lappend result $line

    foreach row $newBoard(indices) {
        set line [list $newBoard(row,$row)]
        foreach col $newBoard(indices) {
            lassign $newBoard($row,$col) value state
            lappend line $value
        }
        lappend result $line
    }
    foreach key $newBoard(indices) {
        if {$newBoard(blob,$key,cells) ne {}} {
            set cells [lsort $newBoard(blob,$key,cells)]
            set line [list blob $key $newBoard(blob,$key) {*}$cells]
            lappend result $line
        }
    }
    return $result
}
proc ::NewBoard::GetSolution {} {
    variable selected
    set result [lmap x $selected { join $x "," }]
    return $result
}

proc ::NewBoard::Debug {{python False}} {
    variable seed
    variable newBoard

    set result ""
    if {! $python} {
        set bsize "$newBoard(size)x$newBoard(size)"
        if {$newBoard(hasBlobs)} { append bsize " 3D" }
        append result "StartGame \"$bsize\" $seed\n\n"
        append result "set size $newBoard(size)\n"
        append result "set seed $seed\n"
        append result "set withBlobs $newBoard(hasBlobs)\n"
        append result "set solution {[::NewBoard::GetSolution]}\n"
        append result "set BB {\n"
        set line "    {xx"
        foreach col $newBoard(indices) {
            append line [format " %2d" $newBoard(col,$col)]
        }
        append result "$line}\n"
        foreach row $newBoard(indices) {
            set line [format "    {%2d" $newBoard(row,$row)]
            foreach col $newBoard(indices) {
                lassign $newBoard($row,$col) value state
                append line [format " %2d" $value]
            }
            append result "$line}\n"
        }
        foreach blobId $newBoard(indices) {
            if {$newBoard(blob,$blobId,cells) eq {}} continue
            append result "    {blob $blobId $newBoard(blob,$blobId)"
            append result " $newBoard(blob,$blobId,cells)}\n"
        }
        append result "}\n"
    } else {
        append result "board = \[\n"
        foreach row $newBoard(indices) {
            set values [lmap k [lsort [array names newBoard $row,*]] {lindex $newBoard($k) 0}]
            set line [join $values ", "]
            append result "    \[$line\],\n"
        }
        append result "\]\n"
    }
    return $result
}
proc ::NewBoard::_Create {size seed withBlobs} {
    variable newBoard

    if {$seed eq "?"} {
        set seed [expr {int(rand() * 2 ** 32)}]
    }
    set ::NewBoard::seed $seed
    expr {srand($seed)}

    set density [expr {int(rand() * 30) + 20}]
    set selectedCount [expr {round(($size * $size) * $density / 100.)}]

    ::NewBoard::_BlankBoard $size $withBlobs
    ::NewBoard::_Blobify
    ::NewBoard::_PickSelected $selectedCount $size
    ::NewBoard::_FillAllCells
    ::NewBoard::_FixDeadlyPatterns
    ::NewBoard::_ComputeSums
}
proc ::NewBoard::_BlankBoard {size withBlobs} {
    variable newBoard
    variable selected
    set selected {}

    unset -nocomplain newBoard
    set newBoard(size) $size
    set newBoard(indices) [lrange {0 1 2 3 4 5 6 7 8 9 10} 0 $size-1]
    set newBoard(hasBlobs) $withBlobs

    foreach row $newBoard(indices) {
        set newBoard(row,$row) 0
        set newBoard(col,$row) 0
        set newBoard(blob,$row) 0
        set newBoard(blob,$row,cells) {}

        foreach col $newBoard(indices) {
            set newBoard($row,$col) [list - normal]
        }
    }
}
proc ::NewBoard::_PickSelected {selectedCount size} {
    variable newBoard
    variable selected
    set selected {}

    # Make sure each row/col slice has a selected element
    foreach sliceType {row col blob} {
        foreach whichSlice $newBoard(indices) {
            if {$sliceType eq "blob" && $newBoard(blob,$whichSlice,cells) eq ""} continue
            set cells [GetAllCellsForSlice ::NewBoard::newBoard $sliceType $whichSlice]
            set pick [lpick $cells]
            lassign $pick row col
            set newBoard($row,$col) [list - select]
            lappend selected $pick
        }
    }

    # Make sure we have selected the right number of cells
    while {[llength $selected] < $selectedCount} {
        set row [expr {int(rand() * $size)}]
        set col [expr {int(rand() * $size)}]
        if {[list $row $col] in $selected} continue

        lappend selected [list $row $col]
        set newBoard($row,$col) [list - select]
    }
}
proc ::NewBoard::_FixDeadlyPatterns {} {
    variable newBoard

    while {True} {
        set deadly [::NewBoard::_CheckForDeadlyPatterns]
        if {$deadly eq {}} break

        foreach box $deadly {
            lassign $box row0 col0 row1 col1

            lassign $newBoard($row0,$col0) value state
            set value [expr {$value == 9 ? 1 : $value + 1}]
            set newBoard($row0,$col0) [list $value $state]
        }
    }

}
proc ::NewBoard::_CheckForDeadlyPatterns {} {
    # If the four corners of any rectangle in the grid are all the
    # same value, then the puzzle has multiple solutions.
    variable newBoard

    set size $newBoard(size)

    set deadly {}
    for {set row0 0} {$row0 < $size-1} {incr row0} {
        for {set col0 0} {$col0 < $size-1} {incr col0} {
            set topLeft [lindex $newBoard($row0,$col0) 0]

            for {set row1 [expr {$row0 + 1}]} {$row1 < $size} {incr row1} {
                if {! [info exists newBoard($row1,$col0)]} continue
                set bottomLeft [lindex $newBoard($row1,$col0) 0]
                if {$topLeft != $bottomLeft} continue

                for {set col1 [expr {$col0 + 1}]} {$col1 < $size} {incr col1} {
                    if {! [info exists newBoard($row0,$col1)]} continue
                    set topRight [lindex $newBoard($row0,$col1) 0]
                    if {$topLeft != $topRight} continue

                    if {! [info exists newBoard($row1,$col1)]} continue
                    set bottomRight [lindex $newBoard($row1,$col1) 0]
                    if {$topLeft == $bottomRight} {
                        lappend deadly [list $row0 $col0 $row1 $col1]
                    }
                }
            }
        }
    }
    return $deadly
}
proc ::NewBoard::_Blobify {} {
    variable newBoard

    foreach idx $newBoard(indices) {
        set newBoard(blob,$idx,cells) {}
    }
    if {! $newBoard(hasBlobs)} return

    if {$::NewBoard::XMODE} {
        set blobs [::Blobs::XBlobs $newBoard(size)]
    } else {
        set blobs [::Blobs::Create $newBoard(size)]
    }

    foreach idx $newBoard(indices) {
        set newBoard(blob,$idx,cells) [dict get $blobs blob,$idx,cells]
    }
}

proc ::NewBoard::_ComputeSums {} {
    variable newBoard


    foreach sliceType {row col blob} {
        foreach whichSlice $newBoard(indices) {
            set sums [GetSliceSums newBoard $sliceType $whichSlice]
            lassign $sums selectedSum unselectedSum
            set newBoard($sliceType,$whichSlice) $selectedSum
        }
    }

    return
}
proc ::NewBoard::_FillAllCells {} {
    variable newBoard

    foreach row $newBoard(indices) {
        foreach col $newBoard(indices) {
            lassign $newBoard($row,$col) _ state
            set value [expr {1 + int(rand() * 9)}]
            set newBoard($row,$col) [list $value $state]
        }
    }
}

proc ::NewBoard::Show {} {
    variable newBoard

    set line ""
    foreach col $newBoard(indices) {
        set ch "--"
        if {[info exists newBoard(col,$col)]} {
            set ch [format %2d $newBoard(col,$col)]
        }
        append line "$ch  "
    }
    puts "   $line"
    puts "   [string repeat = [string length $line]]"

    foreach row $newBoard(indices) {
        set ch "--"
        if {[info exists newBoard(row,$row)]} {
            set ch [format %2d $newBoard(row,$row)]
        }
        puts -nonewline "$ch|"
        foreach col $newBoard(indices) {
            set ch "\u00b7 "
            if {[info exists newBoard($row,$col)]} {
                lassign $newBoard($row,$col) value state
                set ch "$value"
                append ch [expr {$state eq "normal" ? " " : "*"}]
            }
            puts -nonewline " $ch "
        }
        puts ""
    }
}
proc ::NewBoard::ShowInFrame {wFrame} {
    variable newBoard
    variable solution

    set font "[font actual TkDefaultFont] -size 18"

    foreach row $newBoard(indices) {
        foreach col $newBoard(indices) {
            lassign $newBoard($row,$col) digit state
            if {$state eq "select"} {
                set digit [NumberToCircle $digit]
            }
            set w $wFrame._${row}_$col
            ::ttk::label $w -text $digit -font $font
            grid $w -row $row -column $col
        }
    }
}
proc ::NewBoard::FromFile {fname} {
    # Format:
    #  xx ## ## ##
    #  ##  #  #  #
    #  ##  #  #  #
    #  ##  #  #  #
    #  blob ## {r c} {r c} {r c} ...
    #  blob ## {r c} {r c} {r c} ...
    #  blob ## {r c} {r c} {r c} ...

    variable newBoard
    variable selected {}

    if {[info tclversion] >= 9.0} {
        set fname [file tildeexpand $fname]
    }
    set fin [open $fname r]
    set data [split [string trim [read $fin]] \n] ; list
    close $fin
    set lines [lmap l $data {expr {[regexp {^(x|-| ?\d)} $l] ? $l : [continue]}}]
    set blobs [lmap l $data {expr {[regexp {^blob} $l] ? $l : [continue]}}]

    set emsg [::NewBoard::_ValidateFileData $lines]
    if {$emsg ne ""} {
        tk_messageBox -icon warning -message $emsg
        return 0
    }

    set size [expr {[llength $lines] - 1}]

    ::NewBoard::_BlankBoard $size False
    # Extract slice sums
    foreach idx $newBoard(indices) {
        set newBoard(row,$idx) [lindex $lines $idx+1 0]
        set newBoard(col,$idx) [lindex $lines 0 $idx+1]
        set newBoard(blob,$idx) 0
        set newBoard(blob,$idx,cells) {}
    }

    foreach row $newBoard(indices) {
        foreach col $newBoard(indices) {
            set value [lindex $lines $row+1 $col+1]
            set newBoard($row,$col) [list $value normal]
        }
    }

    for {set idx 0} {$idx < [llength $blobs]} {incr idx} {
        set bdata [lindex $blobs $idx]
        set cells [lassign $bdata _ target]
        set cells [lsort $cells]

        set newBoard(blob,$idx) $target
        set newBoard(blob,$idx,cells) $cells
    }
    set newBoard(hasBlobs) [expr {$newBoard(blob,0,cells) ne {}}]

    set isSolvable [::Solve::IsSolvable ::NewBoard::newBoard]
    if {$isSolvable > 0} {
        set selected [::Solve::GetSolution]
    }
    return $isSolvable
}
proc ::NewBoard::_ValidateFileData {lines} {
    set rows [llength $lines]
    set cols [llength [lindex $lines 0]]

    if {$cols != $rows} {
        return "Bad data: number of rows ($rows) doesn't match the number of columns ($cols)"
    }

    for {set row 1} {$row <= $rows} {incr row} {
        set line [lindex $lines $row-1]
        set len [llength $line]
        if {$len != $rows} {
            return "Bad data: line #$row is wrong length: it is $len but should be $rows"
        }
        for {set col 1} {$col <= $rows} {incr col} {
            if {$row == 1 && $col == 1} continue
            set value [lindex $lines $row-1 $col-1]
            if {! [string is integer $value]} {
                return "Bad data: entry in row $row, column $col is not a number: '$value'"
            }
        }
    }

    return ""
}
