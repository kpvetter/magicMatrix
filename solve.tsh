#!/bin/sh
# Restart with tcl: -*- mode: tcl; tab-width: 8; -*- \
exec tclsh $0 ${1+"$@"}

##+##########################################################################
#
# solve.tcl -- <description>
# by Keith Vetter 2025-09-24
#
# XBRD(size) size of puzzle
# XBRD(row,#) row target
# XBRD(col,#) col target
# XBRD(blob,#) blob target
# XBRD(blob,#,cells) <list of {row col}>
# XBRD(#,#) {value state}

namespace eval ::Solve {
    variable solution
}

proc ::Solve::IsSolvable {_BRD} {
    global solvingPasses
    upvar 1 $_BRD BRD

    # Copy board into a temp array
    array set XBRD [array get BRD]

    set solvingPasses 0
    while {1} {
        incr solvingPasses
        set progressMade [::Solve::_Progress XBRD]
        if {! $progressMade} break
    }
    set solved [::Solve::_CheckForSolved XBRD]
    ::Solve::_SaveSolution XBRD

    return $solved
}
proc ::Solve::GetSolution {} {
    return $::Solve::solution
}

proc ::Solve::_CheckForSolved {_XBRD} {
    upvar 1 $_XBRD XBRD

    foreach row $XBRD(indices) {
        foreach col $XBRD(indices) {
            if {[lindex $XBRD($row,$col) 1] eq "normal"} { return 0 }
        }
    }
    return 1
}

proc ::Solve::_Progress {_XBRD} {
    upvar 1 $_XBRD XBRD

    set progressFlag 0
    foreach sliceType {row col blob} {
        if {$sliceType eq "blob" && ! [info exists XBRD(blob,0)]} continue
        foreach whichSlice $XBRD(indices) {
            lassign [::Solve::_TryProgressing XBRD $sliceType $whichSlice] keep delete

            if {[::Solve::_UpdateBoard XBRD $keep $delete]} {
                set progressFlag 1
            }
        }
    }
    return $progressFlag
}
proc ::Solve::_TryProgressing {_XBRD sliceType whichSlice} {
    upvar 1 $_XBRD XBRD
    lassign [::Solve::SingleSlice XBRD $sliceType $whichSlice] keep delete sets
    set keep1 [::Solve::_ConvertToRowCol XBRD $sliceType $whichSlice $keep]
    set delete1 [::Solve::_ConvertToRowCol XBRD $sliceType $whichSlice $delete]
    return [list $keep1 $delete1]
}
proc ::Solve::SingleSlice {_XBRD sliceType whichSlice} {
    upvar 1 $_XBRD XBRD
    lassign [::Solve::_GetSliceData XBRD $sliceType $whichSlice] target cells

    set sets [::Solve::GetSummingSets $target $cells]
    set keep [IntersectionSets [lindex $sets 0] [lrange $sets 1 end]]
    set delete [SubtractSets $cells $sets]

    return [list $keep $delete $sets]
}
proc ::Solve::GetSummingSets {target cells} {
    if {$target < 0} { return {} }
    set sum [expr [join [lmap a $cells { lindex $a 0 }] "+"] + 0]
    if {$sum < $target} { return {} }
    if {$sum == $target} { return [list $cells] }

    set solutions {}
    set remainingCells [lassign $cells firstCell]
    set firstValue [lindex $firstCell 0]

    if {$firstValue == $target} {
        set solutions [list [list $firstCell]]
    }

    # All solutions using the first number
    if {$firstValue < $target} {
        set subTarget [expr {$target - $firstValue}]
        foreach sln [::Solve::GetSummingSets $subTarget $remainingCells] {
            lappend solutions [concat [list $firstCell] $sln]
        }
    }

    # All solutions not using the first number
    foreach sln [::Solve::GetSummingSets $target $remainingCells] {
        lappend solutions $sln
    }
    return $solutions
}
proc ::Solve::_UpdateBoard {_XBRD keep delete} {
    upvar 1 $_XBRD XBRD

    if {$keep eq {} && $delete eq {}} { return 0 }

    foreach cell $keep {
        lassign $cell row col
        lset XBRD($row,$col) 1 select
    }
    foreach cell $delete {
        lassign $cell row col
        lset XBRD($row,$col) 1 kill
    }
    return 1
}
proc ::Solve::_ConvertToRowCol {_XBRD sliceType whichSlice cellList} {
    # Converts from [list {value index} ...] for a given sliceType/whichSlice
    # into [list {row col} {row col} ...]
    upvar 1 $_XBRD XBRD
    set result {}

    if {$sliceType eq "row"} {set row $whichSlice }
    if {$sliceType eq "col"} {set col $whichSlice }
    foreach item $cellList {
        set index [lindex $item 1]
        if {$sliceType eq "row"} {
            set col $index
        } elseif {$sliceType eq "col"} {
            set row $index
        } else {
            lassign [lindex $XBRD(blob,$whichSlice,cells) $index] row col
        }
        lappend result [list $row $col]
    }
    return $result
}
proc ::Solve::_GetSliceData {_XBRD sliceType whichSlice} {
    upvar 1 $_XBRD XBRD

    set selectedSum 0
    set unselectedCells {}
    foreach index $XBRD(indices) {
        if {$sliceType eq "row"} {
            set cell $XBRD($whichSlice,$index)
        } elseif {$sliceType eq "col"} {
            set cell $XBRD($index,$whichSlice)
        } else {
            lassign [lindex $XBRD(blob,$whichSlice,cells) $index] row col
            set cell $XBRD($row,$col)
        }
        lassign $cell value state
        if {$state eq "select"} {
            incr selectedSum $value
        } elseif {$state eq "normal"} {
            lappend unselectedCells [list $value $index]
        }
    }
    set target [expr {$XBRD($sliceType,$whichSlice) - $selectedSum}]
    return [list $target $unselectedCells]
}
proc ::Solve::_SaveSolution {_XBRD} {
    variable solution
    upvar 1 $_XBRD XBRD

    set solution {}
    foreach row $XBRD(indices) {
        foreach col $XBRD(indices) {
            lassign $XBRD($row,$col) value state
            if {$state eq "select"} { lappend solution [list $row $col] }
        }
    }
    return $solution
}

proc ::Solve::ShowBoard {_XBRD} {
    upvar 1 $_XBRD XBRD

    foreach row $XBRD(indices) {
        foreach col $XBRD(indices) {
            lassign $XBRD($row,$col) value state
            set suffix " "
            if {$state eq "kill"} { set suffix "\u2716" }
            if {$state eq "select"} { set suffix "!"}
            puts -nonewline "$value$suffix "
        }
        puts ""
    }
}
