#!/bin/sh
# Restart with tcl: -*- mode: tcl; tab-width: 8; -*- \
exec tclsh $0 ${1+"$@"}

##+##########################################################################
#
# solve.tcl -- <description>
# by Keith Vetter 2025-09-24
#
# XBRD(size) size of puzzle
# XBRD(indices) range($XBRD(size))
# XBRD(row,#) row target
# XBRD(col,#) col target
# XBRD(blob,#) blob target
# XBRD(blob,#,cells) <list of {row col}>
# XBRD(#,#) {value state}
# XBRD(hasBlobs) bool

namespace eval ::Solve {
    variable solution
}

proc ::Solve::IsSolvable {_BRD} {
    # Returns 0 if unsolvable otherwise # of passes required to solve it
    global solvingPasses
    upvar 1 $_BRD BRD

    set XBRD [dict create {*}[array get BRD]]
    set XBRD [::Solve::_NeuterBoard $XBRD]

    set solvingPasses {}
    while {1} {
        lassign [::Solve::_Progress $XBRD] progressMade XBRD
        lappend solvingPasses $progressMade
        if {! $progressMade} break
    }
    ::Solve::_ExtractSolution $XBRD

    set isSolvable [::Solve::_CheckForSolved $XBRD]
    if {$isSolvable} { return [llength $solvingPasses] }
    return 0
}
proc ::Solve::GetSolution {} {
    return $::Solve::solution
}

proc ::Solve::_NeuterBoard {XBRD} {
    set indices [dict get $XBRD indices]
    foreach row $indices {
        foreach col $indices {
            lassign [dict get $XBRD $row,$col] value state
            dict set XBRD $row,$col [list $value "normal"]
        }
    }
    return $XBRD
}

proc ::Solve::_CheckForSolved {XBRD} {
    set indices [dict get $XBRD indices]

    foreach row $indices {
        foreach col $indices {
            lassign [dict get $XBRD $row,$col] value state
            if {$state eq "normal"} { return 0 }
        }
    }
    foreach sliceType {row col blob} {
        if {$sliceType eq "blob" && ! [dict get $XBRD hasBlobs]} continue
        foreach whichSlice $indices {
            lassign [GetSliceSumsDICT $XBRD $sliceType $whichSlice] selectedTotal unselectedTotal
            if {[dict get $XBRD $sliceType,$whichSlice] != $selectedTotal} { return 0 }
        }
    }
    return 1
}

proc ::Solve::_Progress {XBRD} {
    set progressFlag 0
    foreach sliceType {row col blob} {
        if {$sliceType eq "blob" && ! [dict get $XBRD hasBlobs]} continue

        foreach whichSlice [dict get $XBRD indices] {
            lassign [::Solve::_TryProgressing $XBRD $sliceType $whichSlice] keep delete

            if {$keep eq {} && $delete eq {}} continue

            set XBRD [::Solve::_UpdateBoard $XBRD $keep $delete]
            incr progressFlag
        }
    }
    return [list $progressFlag $XBRD]
}
proc ::Solve::_TryProgressing {XBRD sliceType whichSlice} {
    lassign [::Solve::SingleSlice $XBRD $sliceType $whichSlice] keep delete sets
    set keep1 [::Solve::_ConvertToRowCol $XBRD $sliceType $whichSlice $keep]
    set delete1 [::Solve::_ConvertToRowCol $XBRD $sliceType $whichSlice $delete]
    return [list $keep1 $delete1]
}
proc ::Solve::SingleSliceARRAY {_XBRD sliceType whichSlice} {
    upvar 1 $_XBRD __XBRD
    set XBRD [dict create {*}[array get __XBRD]]

    lassign [::Solve::_GetSliceData $XBRD $sliceType $whichSlice] target cells

    set sets [::Solve::_GetSummingSets $target $cells]
    set keep [IntersectionSets [lindex $sets 0] [lrange $sets 1 end]]
    set delete [SubtractSets $cells $sets]

    return [list $keep $delete $sets]
}

proc ::Solve::SingleSlice {XBRD sliceType whichSlice} {
    # Returns three lists of cells (each cell is {value index})
    # * keep : cells the slice must have
    # * delete : cells the slice must not have
    # * sets : all combinations of cells that sum to the target

    lassign [::Solve::_GetSliceData $XBRD $sliceType $whichSlice] target cells

    set sets [::Solve::_GetSummingSets $target $cells]
    set keep [IntersectionSets [lindex $sets 0] [lrange $sets 1 end]]
    set delete [SubtractSets $cells $sets]

    return [list $keep $delete $sets]
}

proc ::Solve::_GetSummingSets {target cells} {
    if {$target < 0} { return {} }
    set sum [expr [join [lmap a $cells { lindex $a 0 }] "+"] + 0]
    if {$sum < $target} { return {} }
    if {$sum == $target} { return [list $cells] }

    set solutions {}
    set remainingCells [lassign $cells firstCell]
    set firstValue [lindex $firstCell 0]

    if {$firstValue == $target} {
        set solutions [list [list $firstCell]]
    }

    # All solutions using the first number
    if {$firstValue < $target} {
        set subTarget [expr {$target - $firstValue}]
        foreach sln [::Solve::_GetSummingSets $subTarget $remainingCells] {
            lappend solutions [concat [list $firstCell] $sln]
        }
    }

    # All solutions not using the first number
    foreach sln [::Solve::_GetSummingSets $target $remainingCells] {
        lappend solutions $sln
    }
    return $solutions
}
proc ::Solve::_UpdateBoard {XBRD keep delete} {

    foreach cell $keep {
        lassign $cell row col
        lassign [dict get $XBRD $row,$col] value state
        dict set XBRD $row,$col [list $value "select"]
    }
    foreach cell $delete {
        lassign $cell row col
        lassign [dict get $XBRD $row,$col] value state
        dict set XBRD $row,$col [list $value "kill"]
    }
    return $XBRD
}
proc ::Solve::_ConvertToRowCol {XBRD sliceType whichSlice cellList} {
    # Converts from [list {value index} ...] for a given sliceType/whichSlice
    # into [list {row col} {row col} ...]
    set result {}

    if {$sliceType eq "row"} {set row $whichSlice }
    if {$sliceType eq "col"} {set col $whichSlice }
    foreach item $cellList {
        set index [lindex $item 1]
        if {$sliceType eq "row"} {
            set col $index
        } elseif {$sliceType eq "col"} {
            set row $index
        } else {
            lassign [lindex [dict get $XBRD blob,$whichSlice,cells] $index] row col
        }
        lappend result [list $row $col]
    }
    return $result
}
proc ::Solve::_GetSliceData {XBRD sliceType whichSlice} {
    # returns: NEEDED [list unselected cell ...] where each unselected cell is {value index}
    # e.g.  3 {1 3} {7 4} {6 6} {8 7}

    set selectedSum 0
    set unselectedCells {}
    set all_coords [GetAllCellsForSliceDICT $XBRD $sliceType $whichSlice]
    set index -1
    foreach coords $all_coords {
        incr index

        lassign $coords row col
        set cell [dict get $XBRD $row,$col]
        lassign $cell value state
        if {$state eq "select"} {
            incr selectedSum $value
        } elseif {$state eq "normal"} {
            lappend unselectedCells [list $value $index]
        }
    }
    set target [expr {[dict get $XBRD $sliceType,$whichSlice] - $selectedSum}]
    return [list $target $unselectedCells]
}
proc ::Solve::_ExtractSolution {XBRD} {
    variable solution

    set solution {}
    foreach row [dict get $XBRD indices] {
        foreach col [dict get $XBRD indices] {
            lassign [dict get $XBRD $row,$col] value state
            if {$state eq "select"} {
                lappend solution [list $row $col]
            }
        }
    }
}

proc ::Solve::ShowBoard {board {showBlobs False}} {
    set size [dict get $board size]
    set indices [dict get $board indices]

    set width [expr {3 * $size + 1}]
    set horizontal [string repeat "\u2501" $width]

    puts "    [join $indices {  }]"
    puts "  \u250f$horizontal\u2513"
    foreach row $indices {
        puts -nonewline "$row \u2503 "
        foreach col $indices {
            lassign [dict get $board $row,$col] value state
            set suffix " "
            if {$state eq "kill"} { set suffix "\u2716" }
            if {$state eq "select"} { set suffix "*"}
            puts -nonewline "$value$suffix "
        }
        puts -nonewline "\u2503"
        set blobCells [dict get $board blob,$row,cells]
        if {$showBlobs && $blobCells ne {}} {
            set pretty [lmap x $blobCells { join $x "," }]
            puts -nonewline "  blob $row: $pretty"
        }
        puts ""
    }
    puts "  \u2517$horizontal\u251b"
}
