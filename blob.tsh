#!/bin/sh
# Restart with tcl: -*- mode: tcl; tab-width: 8; -*- \
exec tclsh $0 ${1+"$@"}

##+##########################################################################
#
# kblob.tsh -- <description>
# by Keith Vetter 2025-11-18
#

set CELL_EMPTY "-"

proc GrowAllBlobs {size} {
    set board [CreateBoard $size]

    foreach blobId [dict get $board indices] {
        set board [GrowOneBlob $board $blobId]
    }
    return $board
}
proc GrowOneBlob {board blobId} {
    set blobSymbol [lindex {A B C D E F G H I J K L} $blobId]

    set emptyCells [ExtractBlob $board $::CELL_EMPTY]

    set nextBoard $board
    set firstCell [lpick $emptyCells]
    lassign $firstCell row col
    dict set nextBoard $row,$col $blobSymbol
    dict lappend nextBoard blob,$blobId,cells $firstCell

    if {[dict get $nextBoard size] == 1} { return $nextBoard }

    set queue [list $nextBoard]
    set nextBoard [_GrowOneBlobQueue $queue $blobId]
    return $nextBoard
}
proc _GrowOneBlobQueue {queue blobId} {
    set size [dict get [lindex $queue 0] size]
    set blobSymbol [lindex {A B C D E F G H I J K L} $blobId]
    while {[llength $queue] > 0} {
        set queue [lassign $queue board]
        set neighbors [GetAllEmptyNeighbors $board $blobId]

        foreach cell $neighbors {
            lassign $cell row col
            set nextBoard $board
            dict set nextBoard $row,$col $blobSymbol
            dict lappend nextBoard blob,$blobId,cells $cell

            if {! [IsValidBoard $nextBoard $blobId]} continue

            set queue [linsert $queue 0 $nextBoard]
            set blobCells [dict get $nextBoard blob,$blobId,cells]
            if {[llength $blobCells] == $size} {
                return [lindex $queue 0]
            }
        }
    }
    error "no blob could be created"
}
proc IsValidBoard {board blobId} {
    set size [dict get $board size]
    set blobCells [dict get $board blob,$blobId,cells]

    set stillNeeded [expr {$size - [llength $blobCells]}]
    set lakes [FindAllLakes $board]
    foreach lake $lakes {
        set excess [expr {[llength $lake] % $size}]
        if {$excess == 0} continue
        if {$excess > $stillNeeded} { return False }
        set stillNeeded [expr {$stillNeeded - $excess}]
    }
    set result [expr {$stillNeeded == 0}]
    return $result
}
proc ShowBoard {board {showBlobs False}} {
    set size [dict get $board size]
    set indices [dict get $board indices]

    set width [expr {2 * $size + 1}]
    set horizontal [string repeat "\u2501" $width]

    puts "    $indices"
    puts "  \u250f$horizontal\u2513"
    foreach row $indices {
        puts -nonewline "$row \u2503 "
        foreach col $indices {
            puts -nonewline "[dict get $board $row,$col] "
        }
        puts -nonewline "\u2503"
        set blobCells [dict get $board blob,$row,cells]
        if {$showBlobs && $blobCells ne {}} {
            set pretty [lmap x $blobCells { join $x "," }]
            puts -nonewline "  blob $row: $pretty"
        }
        puts ""
    }
    puts "  \u2517$horizontal\u251b"
}

proc CreateBoard {size} {
    set indices [lrange {0 1 2 3 4 5 6 7 8 9 10 11} 0 $size-1]
    set board [dict create size $size indices $indices]

    foreach row $indices {
        dict set board blob,$row,cells {}
        foreach col $indices {
            dict set board $row,$col $::CELL_EMPTY
        }
    }
    return $board
}

proc ExtractBlob {board blobSymbol} {
    set indices [dict get $board indices]

    set emptyCells {}
    foreach row $indices {
        foreach col $indices {
            set value [dict get $board $row,$col]
            if {$value eq $blobSymbol} {
                lappend emptyCells [list $row $col]
            }
        }
    }
    return $emptyCells
}
proc lpick {llist} {
    set idx [expr {int(rand() * [llength $llist])}]
    return [lindex $llist $idx]
}

proc GetAllEmptyNeighbors {board blobId} {
    set size [dict get $board size]
    set blobCells [dict get $board blob,$blobId,cells]

    set neighbors {}
    foreach cell $blobCells {
        lassign $cell row0 col0
        foreach {drow dcol} {0 1 0 -1 1 0 -1 0} {
            set row [expr {$row0 + $drow}]
            set col [expr {$col0 + $dcol}]
            if {$row < 0 || $row >= $size} continue
            if {$col < 0 || $col >= $size} continue
            set value [dict get $board $row,$col]
            if {$value ne $::CELL_EMPTY} continue
            lappend neighbors [list $row $col]
        }
    }
    set neighbors [Shuffle $neighbors]
    return $neighbors
}
proc Shuffle {myList} {
    set len [llength $myList]
    while {$len} {
        set n [expr {int($len*rand())}]
        set tmp [lindex $myList $n]
        lset myList $n [lindex $myList [incr len -1]]
        lset myList $len $tmp
    }
    return $myList
}


proc FloodFill {board row0 col0 oldValue newValue} {
    if {[dict get $board $row0,$col0] != $oldValue} {
        return [list $board {}]
    }

    set floodBoard $board
    set size [dict get $floodBoard size]
    set Q [list [list $row0 $col0]]

    set floodCells {}
    while {[llength $Q] > 0} {
        set Q [lassign $Q cell]
        lassign $cell row col
        dict set floodBoard $row,$col $newValue
        lappend floodCells [list $row $col]

        foreach {drow dcol} {-1 0 1 0 0 1 0 -1} {
            set row1 [expr {$row + $drow}]
            set col1 [expr {$col + $dcol}]
            if {$row1 < 0 || $row1 >= $size || $col1 < 0 || $col1 >= $size} continue
            if {[dict get $floodBoard $row1,$col1] != $oldValue} continue

            set newCell [list $row1 $col1]
            if {$newCell ni $Q} {
                lappend Q $newCell
            }
        }
    }

    return [list $floodBoard $floodCells]
}
proc test_floodFill {} {
    set data {"---A" "A---" "-A---" "-AAA"}
    set board [DecodeBoard $data]

    lassign [FloodFill $board 1 1 $::CELL_EMPTY "B"] board floodCells
    ShowBoard $board

    lassign [FloodFill $board 3 0 $::CELL_EMPTY "C"] board floodCells
    ShowBoard $board
    return $board
}


proc FindAllLakes {board} {
    set all_lakes {}
    set floodBoard $board

    set idx -1
    while {1} {
        incr idx
        set floodSymbol [lindex {a b c d e f g h i j k} $idx]

        set empty [ExtractBlob $floodBoard $::CELL_EMPTY]
        if {$empty eq {}} break
        lassign [lindex $empty 0] row col

        lassign [FloodFill $floodBoard $row $col $::CELL_EMPTY $floodSymbol] floodBoard lake
        lappend all_lakes $lake
    }
    return $all_lakes
}
proc test_FindAllLakes {} {
    set data {"----" "-AAA" "-AAA" "--AA"}
    set board [DecodeBoard $data]
    set lakes [FindAllLakes $board]
    puts "[llength $lakes] $lakes"

    set data {"----" "-AAA" "-A--" "--AA"}
    set board [DecodeBoard $data]
    set lakes [FindAllLakes $board]
    puts "[llength $lakes] $lakes"

}

proc DecodeBoard {data} {
    set size [llength $data]
    set board [CreateBoard $size]
    set indices [dict get $board indices]

    foreach row $indices datum $data {
        foreach col $indices char [split $datum ""] {
            dict set board $row,$col $char
        }
    }
    return $board
}
if {0} {
    set bad {"AA---" "BAAA-" "B----" "BBCC-" "BCCCC"}
    set board [DecodeBoard $bad]
    dict set board blob,0,cells [ExtractBlob $board "A"]
    dict set board blob,1,cells [ExtractBlob $board "B"]
    dict set board blob,2,cells [ExtractBlob $board "C"]
    ShowBoard $board
    GrowOneBlob $board 3
}
set board [GrowAllBlobs 9]
ShowBoard $board
