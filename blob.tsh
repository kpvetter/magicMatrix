#!/bin/sh
# Restart with tcl: -*- mode: tcl; tab-width: 8; -*- \
exec tclsh $0 ${1+"$@"}

##+##########################################################################
#
# kblob.tsh -- <description>
# by Keith Vetter 2025-11-18
#


namespace eval ::Blobs {
    variable CELL_EMPTY "-"
}

proc ::Blobs::Create {size} {
    set board [::Blobs::_CreateBoard $size]

    foreach blobId [dict get $board indices] {
        set board [::Blobs::_GrowOne $board $blobId]
        if {$board eq ""} break
    }
    return $board
}
proc ::Blobs::_GrowOne {board blobId} {
    variable CELL_EMPTY
    set blobSymbol [lindex {A B C D E F G H I J K L} $blobId]

    set emptyCells [::Blobs::_ExtractBlob $board $CELL_EMPTY]

    set nextBoard $board
    set firstCell [lpick $emptyCells]
    lassign $firstCell row col
    dict set nextBoard $row,$col $blobSymbol
    dict lappend nextBoard blob,$blobId,cells $firstCell

    if {[dict get $nextBoard size] == 1} { return $nextBoard }

    set queue [list $nextBoard]
    set nextBoard [::Blobs::_GrowOneQueue $queue $blobId]
    return $nextBoard
}
proc ::Blobs::_GrowOneQueue {queue blobId} {
    set size [dict get [lindex $queue 0] size]
    set blobSymbol [lindex {A B C D E F G H I J K L} $blobId]
    while {[llength $queue] > 0} {
        set queue [lassign $queue board]
        set neighbors [::Blobs::_GetAllEmptyNeighbors $board $blobId]

        foreach cell $neighbors {
            lassign $cell row col
            set nextBoard $board
            dict set nextBoard $row,$col $blobSymbol
            dict lappend nextBoard blob,$blobId,cells $cell

            if {! [::Blobs::_IsValidBoard $nextBoard $blobId]} continue

            set queue [linsert $queue 0 $nextBoard]
            set blobCells [dict get $nextBoard blob,$blobId,cells]
            if {[llength $blobCells] == $size} {
                return [lindex $queue 0]
            }
        }
    }
    return ""
}
proc ::Blobs::_IsValidBoard {board blobId} {
    set size [dict get $board size]
    set blobCells [dict get $board blob,$blobId,cells]

    set stillNeeded [expr {$size - [llength $blobCells]}]
    set lakes [::Blobs::_FindAllLakes $board]
    foreach lake $lakes {
        set excess [expr {[llength $lake] % $size}]
        if {$excess == 0} continue
        if {$excess > $stillNeeded} { return False }
        set stillNeeded [expr {$stillNeeded - $excess}]
    }
    set result [expr {$stillNeeded == 0}]
    return $result
}
proc ::Blobs::ShowBoard {board {showBlobs False}} {
    set size [dict get $board size]
    set indices [dict get $board indices]

    set width [expr {2 * $size + 1}]
    set horizontal [string repeat "\u2501" $width]

    puts "    $indices"
    puts "  \u250f$horizontal\u2513"
    foreach row $indices {
        puts -nonewline "$row \u2503 "
        foreach col $indices {
            lassign [dict get $board $row,$col] value state
            puts -nonewline "$value "
        }
        puts -nonewline "\u2503"
        set blobCells [dict get $board blob,$row,cells]
        if {$showBlobs && $blobCells ne {}} {
            set pretty [lmap x $blobCells { join $x "," }]
            puts -nonewline "  blob $row: $pretty"
        }
        puts ""
    }
    puts "  \u2517$horizontal\u251b"
}

proc ::Blobs::_CreateBoard {size} {
    variable CELL_EMPTY
    set indices [lrange {0 1 2 3 4 5 6 7 8 9 10 11} 0 $size-1]
    set board [dict create size $size indices $indices]

    foreach row $indices {
        dict set board blob,$row,cells {}
        foreach col $indices {
            dict set board $row,$col $CELL_EMPTY
        }
    }
    return $board
}

proc ::Blobs::_ExtractBlob {board blobSymbol} {
    set indices [dict get $board indices]

    set emptyCells {}
    foreach row $indices {
        foreach col $indices {
            set value [dict get $board $row,$col]
            if {$value eq $blobSymbol} {
                lappend emptyCells [list $row $col]
            }
        }
    }
    return $emptyCells
}

proc ::Blobs::_GetAllEmptyNeighbors {board blobId} {
    variable CELL_EMPTY
    set size [dict get $board size]
    set blobCells [dict get $board blob,$blobId,cells]

    set neighbors {}
    foreach cell $blobCells {
        lassign $cell row0 col0
        foreach {drow dcol} {0 1 0 -1 1 0 -1 0} {
            set row [expr {$row0 + $drow}]
            set col [expr {$col0 + $dcol}]
            if {$row < 0 || $row >= $size} continue
            if {$col < 0 || $col >= $size} continue
            set value [dict get $board $row,$col]
            if {$value ne $CELL_EMPTY} continue
            lappend neighbors [list $row $col]
        }
    }
    set neighbors [Shuffle $neighbors]
    return $neighbors
}

proc ::Blobs::_FloodFill {board row0 col0 oldValue newValue} {
    if {[dict get $board $row0,$col0] != $oldValue} {
        return [list $board {}]
    }

    set floodBoard $board
    set size [dict get $floodBoard size]
    set Q [list [list $row0 $col0]]

    set floodCells {}
    while {[llength $Q] > 0} {
        set Q [lassign $Q cell]
        lassign $cell row col
        dict set floodBoard $row,$col $newValue
        lappend floodCells [list $row $col]

        foreach {drow dcol} {-1 0 1 0 0 1 0 -1} {
            set row1 [expr {$row + $drow}]
            set col1 [expr {$col + $dcol}]
            if {$row1 < 0 || $row1 >= $size || $col1 < 0 || $col1 >= $size} continue
            if {[dict get $floodBoard $row1,$col1] != $oldValue} continue

            set newCell [list $row1 $col1]
            if {$newCell ni $Q} {
                lappend Q $newCell
            }
        }
    }

    return [list $floodBoard $floodCells]
}
proc ::Blobs::test_FloodFill {} {
    variable CELL_EMPTY
    set data {"---A" "A---" "-A---" "-AAA"}
    set board [::Blobs::_DecodeBoard $data]

    lassign [::Blobs::_FloodFill $board 1 1 $CELL_EMPTY "B"] board floodCells
    ::Blobs::ShowBoard $board

    lassign [::Blobs::_FloodFill $board 3 0 $CELL_EMPTY "C"] board floodCells
    ::Blobs::ShowBoard $board
    return $board
}


proc ::Blobs::_FindAllLakes {board} {
    variable CELL_EMPTY
    set all_lakes {}
    set floodBoard $board

    set idx -1
    while {1} {
        incr idx
        set floodSymbol [lindex {a b c d e f g h i j k} $idx]

        set empty [::Blobs::_ExtractBlob $floodBoard $CELL_EMPTY]
        if {$empty eq {}} break
        lassign [lindex $empty 0] row col

        lassign [::Blobs::_FloodFill $floodBoard $row $col $CELL_EMPTY $floodSymbol] floodBoard lake
        lappend all_lakes $lake
    }
    return $all_lakes
}
proc Blobs::test_FindAllLakes {} {
    set data {"----" "-AAA" "-AAA" "--AA"}
    set board [::Blobs::_DecodeBoard $data]
    set lakes [::Blobs::_FindAllLakes $board]
    puts "[llength $lakes] $lakes"

    set data {"----" "-AAA" "-A--" "--AA"}
    set board [::Blobs::_DecodeBoard $data]
    set lakes [::Blobs::_FindAllLakes $board]
    puts "[llength $lakes] $lakes"

}

proc ::Blobs::_DecodeBoard {data} {
    set size [llength $data]
    set board [::Blobs::_CreateBoard $size]
    set indices [dict get $board indices]

    foreach row $indices datum $data {
        foreach col $indices char [split $datum ""] {
            dict set board $row,$col $char
        }
    }
    return $board
}
################################################################
proc Shuffle {myList} {
    set len [llength $myList]
    while {$len} {
        set n [expr {int($len*rand())}]
        set tmp [lindex $myList $n]
        lset myList $n [lindex $myList [incr len -1]]
        lset myList $len $tmp
    }
    return $myList
}
proc lpick {llist} {
    set idx [expr {int(rand() * [llength $llist])}]
    return [lindex $llist $idx]
}
proc Comma {num} {
    while {[regsub {^([-+]?[0-9]+)([0-9][0-9][0-9])} $num {\1,\2} num]} {}
    return $num
}
proc TimeIt {count boardSize} {
    puts "starting timer for creating [Comma $count] boards of size $boardSize"
    set start [clock milliseconds]
    set failures 0
    for {set i 0} {$i < $count} {incr i} {
        set board [::Blobs::Create $boardSize]
        if {$board eq ""} { incr failures }
    }
    set stop [clock milliseconds]
    set total [expr {$stop - $start}]
    puts "$count -> [Comma $total]ms  failures: $failures"
}

if {0} {
    set bad {"AA---" "BAAA-" "B----" "BBCC-" "BCCCC"}
    set board [::Blobs::_DecodeBoard $bad]
    dict set board blob,0,cells [::Blobs::_ExtractBlob $board "A"]
    dict set board blob,1,cells [::Blobs::_ExtractBlob $board "B"]
    dict set board blob,2,cells [::Blobs::_ExtractBlob $board "C"]
    ::Blobs::ShowBoard $board
    ::Blobs::_GrowOne $board 3
}
set board [::Blobs::Create 9]
::Blobs::ShowBoard $board

TimeIt 100 9
